{"version":3,"file":"datastore.js","sourceRoot":"","sources":["../../../src/datastore/pinecone/datastore.ts"],"names":[],"mappings":"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","sourcesContent":["import { AbstractDatastore } from '../datastore.js';\nimport type { Datastore, Prettify } from '../types.js';\nimport type { PineconeClient } from './client.js';\nimport { createPineconeClient } from './client.js';\nimport type { Pinecone } from './types.js';\n\nexport class PineconeDatastore<\n  DocMeta extends Datastore.BaseMeta\n> extends AbstractDatastore<DocMeta, Pinecone.QueryFilter<DocMeta>> {\n  datastoreType = 'embedding' as const;\n  datastoreProvider = 'pinecone' as const;\n  private readonly pinecone: PineconeClient<DocMeta>;\n\n  constructor(\n    args: Prettify<\n      Datastore.Opts<DocMeta, Pinecone.QueryFilter<DocMeta>> & {\n        pinecone?: PineconeClient<DocMeta>;\n      }\n    >\n  ) {\n    const { pinecone, ...rest } = args;\n    super(rest);\n    this.pinecone =\n      pinecone ||\n      createPineconeClient<DocMeta>({\n        namespace: this.namespace,\n      });\n  }\n\n  async runQuery(\n    query: Datastore.Query<DocMeta, Pinecone.QueryFilter<DocMeta>>,\n    context?: Datastore.Ctx\n  ): Promise<Datastore.QueryResult<DocMeta>> {\n    const mergedContext = { ...this.context, ...context };\n\n    // Get the query embedding\n    let queryEmbedding = query.embedding;\n\n    // If no query embedding is provided, run the query embedder\n    if (!queryEmbedding) {\n      const { embeddings } = await this.embeddingModel.run(\n        {\n          input: [query.query],\n        },\n        mergedContext\n      );\n      const embedding = embeddings[0];\n      queryEmbedding = embedding;\n    }\n\n    // Query Pinecone\n    const response = await this.pinecone.query({\n      topK: query.topK ?? 10,\n      ...(typeof query.minScore === 'number'\n        ? { minScore: query.minScore }\n        : {}),\n      ...(query.filter && { filter: query.filter }),\n      ...(typeof query.hybridAlpha === 'number' && {\n        hybridAlpha: query.hybridAlpha,\n      }),\n      includeValues: query.includeValues ?? false,\n      includeMetadata: true,\n      vector: queryEmbedding,\n    });\n\n    const queryResult: Datastore.QueryResult<DocMeta> = {\n      query: query.query,\n      docs: response.matches,\n    };\n\n    return queryResult;\n  }\n\n  async upsert(\n    docs: Datastore.Doc<DocMeta>[],\n    context?: Datastore.Ctx\n  ): Promise<void> {\n    const mergedContext = { ...this.context, ...context };\n    try {\n      // Get the text from the docs that are missing an embedding\n      const textsToEmbed = docs\n        .filter((doc) => !doc.embedding?.length)\n        .map((doc) => {\n          const content = doc.metadata[this.contentKey];\n          if (typeof content !== 'string') {\n            throw new Error(\n              `The value of the contentKey (${String(\n                this.contentKey\n              )}) must be a string`\n            );\n          }\n          return content;\n        });\n\n      if (textsToEmbed.length === 0) {\n        return this.pinecone.upsert({\n          vectors: docs.map((doc, i) => ({\n            id: doc.id,\n            values: docs[i].embedding as number[],\n            metadata: doc.metadata,\n          })),\n        });\n      }\n\n      // Create the embedding for docs that are missing one\n      // This relies on the classes to handle batching and throttling\n      const embeddingRes = await this.embeddingModel.run(\n        { input: textsToEmbed },\n        mergedContext\n      );\n      const embeddings = embeddingRes.embeddings;\n\n      // Merge the existing embeddings and sparse vectors with the generated ones\n      const docsWithEmbeddings = docs.map((doc) => {\n        let embedding = doc.embedding;\n        // If the doc was missing an embedding, use the generated one\n        if (!embedding) {\n          embedding = embeddings.shift();\n          if (!embedding) {\n            throw new Error('Unexpected missing embedding');\n          }\n        }\n        return { ...doc, embedding };\n      });\n\n      // Combine the results into Pinecone's vector format and upsert\n      // The Pinecone client will handle batching and throttling\n      return this.pinecone.upsert({\n        vectors: docs.map((doc, i) => ({\n          id: doc.id,\n          values: docsWithEmbeddings[i].embedding,\n          metadata: doc.metadata,\n        })),\n      });\n    } catch (error) {\n      await Promise.allSettled(\n        this.events?.onError?.map((event) =>\n          Promise.resolve(\n            event({\n              timestamp: new Date().toISOString(),\n              datastoreType: this.datastoreType,\n              datastoreProvider: this.datastoreProvider,\n              error,\n              context: mergedContext,\n            })\n          )\n        ) ?? []\n      );\n      throw error;\n    }\n  }\n\n  async delete(docIds: string[]): Promise<void> {\n    return this.pinecone.delete({ ids: docIds });\n  }\n\n  async deleteAll(): Promise<void> {\n    return this.pinecone.delete({ deleteAll: true });\n  }\n}\n"]}