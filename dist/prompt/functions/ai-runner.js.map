{"version":3,"file":"ai-runner.js","sourceRoot":"","sources":["../../../src/prompt/functions/ai-runner.ts"],"names":[],"mappings":"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","sourcesContent":["import pMap from 'p-map';\nimport { Msg, getErrorMsg } from '../index.js';\nimport type { Prompt } from '../types.js';\nimport type { Model } from '../../index.js';\n\n/**\n * Creates a function to run a chat model in a loop\n * - Handles parsing, running, and inserting responses for function & tool call messages\n * - Handles errors by adding a message with the error and rerunning the model\n * - Optionally validates the content of the last message\n */\nexport function createAIRunner<Content extends any = string>(args: {\n  /** The ChatModel used to make API calls. */\n  chatModel: Model.Chat.Model;\n  /** The functions the model can call. */\n  functions?: Prompt.AIFunction[];\n  /** Use this to control when the runner should stop. */\n  shouldBreakLoop?: (msg: Prompt.Msg) => boolean;\n  /** The maximum number of iterations before the runner throws an error. An iteration is a single call to the model/API. */\n  maxIterations?: number;\n  /** The number of function calls to make concurrently. */\n  functionCallConcurrency?: number;\n  /** Parse and validate the content of the last message. */\n  validateContent?: (content: string | null) => Content | Promise<Content>;\n  /** Controls whether functions or tool_calls are used. */\n  mode?: Prompt.Runner.Mode;\n  /** Add a system message to the beginning of the messages array. */\n  systemMessage?: string;\n  /** Called when a retriable error occurs. */\n  onRetriableError?: (error: Error) => void;\n}): Prompt.Runner<Content> {\n  /** Return the content string or an empty string if null. */\n  function defaultValidateContent(content: string | null): Content {\n    return (content ?? '') as Content;\n  }\n\n  /** Break when an assistant message with content is received. */\n  function defaultShouldBreakLoop(msg: Prompt.Msg): boolean {\n    return msg.role === 'assistant' && msg.content !== null;\n  }\n\n  /** Execute the runner and return the messages and content of the last message. */\n  return async function run(params, context) {\n    const {\n      chatModel,\n      functions,\n      mode = 'tools',\n      maxIterations = 5,\n      functionCallConcurrency,\n      systemMessage,\n      validateContent = defaultValidateContent,\n      shouldBreakLoop = defaultShouldBreakLoop,\n    } = args;\n\n    // Add the functions/tools to the model params\n    const additonalParams = getParams({ functions, mode });\n\n    // Create a message from the input if it's a string\n    const { messages, ...modelParams }: Model.Chat.Run =\n      typeof params === 'string'\n        ? {\n            messages: [Msg.user(params)],\n          }\n        : params;\n    if (systemMessage) {\n      messages.unshift(Msg.system(systemMessage));\n    }\n\n    let iterations = 0;\n\n    // Store the last error to return if the maxIterations is reached\n    let lastError: unknown | undefined;\n\n    // Store the last response message from the model\n    let lastResponseMessage: Prompt.Msg | undefined;\n\n    // Iterate until the shouldBreakLoop function returns true or the maxIterations\n    // is reached\n    while (iterations < maxIterations) {\n      iterations++;\n\n      try {\n        // Run the model with the current messages and functions/tools\n        const runParams = {\n          ...modelParams,\n          ...additonalParams,\n          messages,\n        };\n        const { message } = await chatModel.run(runParams, context);\n        lastResponseMessage = message;\n        messages.push(message);\n\n        // Run functions from tool/function call messages and append the new messages\n        const newMessages = await handleFunctionCallMessage({\n          message,\n          functions,\n          functionCallConcurrency,\n        });\n        messages.push(...newMessages);\n\n        // Check if the last message should break the loop\n        const lastMessage = messages[messages.length - 1];\n        if (shouldBreakLoop(lastMessage)) {\n          const content = await Promise.resolve(\n            validateContent(lastMessage.content)\n          );\n          return { status: 'success', messages, content };\n        }\n      } catch (error: any) {\n        // Halt the runner and return an error if the error is an AbortError\n        if (error.name === 'AbortError') {\n          return { status: 'error', messages, error };\n        }\n\n        // Update the last error\n        lastError = error;\n\n        // Call the onRetriableError callback if provided\n        args.onRetriableError?.(error);\n\n        // Otherwise, create a message with the error and continue iterating,\n        // with special handling for tool_calls errors that must be followed\n        // by a tools message.\n        const errMessage = getErrorMsg(error);\n        if (lastResponseMessage && Msg.isToolCall(lastResponseMessage)) {\n          lastResponseMessage.tool_calls.forEach((toolCall) => {\n            messages.push(\n              Msg.toolResult(\n                {\n                  message: `There was an error validating the tool arguments. Please check the error message and try again with new arguments.`,\n                  errorMessage: errMessage,\n                },\n                toolCall.id\n              )\n            );\n          });\n        } else {\n          messages.push(\n            Msg.user(\n              `There was an error validating the response. Please check the error message and try again.\\nError:\\n${errMessage}`\n            )\n          );\n        }\n      }\n    }\n\n    // Return the last error if present, otherwise return a generic error\n    if (lastError !== undefined) {\n      return { status: 'error', messages, error: lastError };\n    } else {\n      const error = new Error(\n        `Failed to get a valid response from the model after ${maxIterations} iterations.`\n      );\n      return { status: 'error', messages, error };\n    }\n  };\n}\n\n/** Get the chat model params for the tools or functions. */\nfunction getParams(args: {\n  functions?: Prompt.AIFunction[];\n  mode: Prompt.Runner.Mode;\n}): Pick<Model.Chat.Config, 'functions' | 'tools'> {\n  const { functions } = args;\n  // Return an empty object if there are no functions\n  if (!functions?.length) {\n    return {};\n  }\n\n  // Use the functions mode if explicitly set\n  if (args.mode === 'functions') {\n    return { functions: functions.map((func) => func.spec) };\n  }\n\n  // Otherwise, default to the tools mode\n  return {\n    tools: functions.map((func) => ({\n      type: 'function' as const,\n      function: func.spec,\n    })),\n  };\n}\n\n/**\n * Handle messages that require calling functions.\n * @returns An array of the new messages from the function calls\n * Note: Does not include args.message in the returned array\n */\nexport async function handleFunctionCallMessage(args: {\n  message: Prompt.Msg;\n  functions?: Prompt.AIFunction[];\n  functionCallConcurrency?: number;\n}): Promise<Prompt.Msg[]> {\n  const { message, functions = [], functionCallConcurrency = 8 } = args;\n  const messages: Prompt.Msg[] = [message];\n  const funcMap = getFuncMap(functions);\n\n  /** Call a function and return the result. */\n  async function callFunction(args: { name: string; arguments: string }) {\n    const { arguments: funcArgs, name } = args;\n    const func = funcMap.get(name);\n    if (!func) {\n      throw new Error(`No function found with name: ${name}`);\n    }\n\n    try {\n      return await func(funcArgs);\n    } catch (err: any) {\n      if (err.name === 'AbortError') {\n        throw err;\n      }\n\n      // Augment any function errors with the name of the function\n      throw new Error(`Error running function \"${name}\": ${err.message}`, {\n        cause: err,\n      });\n    }\n  }\n\n  // Run the function with the given name and arguments and add the result messages.\n  if (Msg.isFuncCall(message)) {\n    const result = await callFunction(message.function_call);\n    messages.push(Msg.funcResult(result, message.function_call.name));\n  }\n\n  // Run all the tool_calls functions and add the result messages.\n  if (Msg.isToolCall(message)) {\n    await pMap(\n      message.tool_calls,\n      async (toolCall) => {\n        const result = await callFunction(toolCall.function);\n        messages.push(Msg.toolResult(result, toolCall.id));\n      },\n      { concurrency: functionCallConcurrency }\n    );\n  }\n\n  return messages.slice(1);\n}\n\n/** Create a map of function names to functions for easy lookup. */\nfunction getFuncMap(functions: Prompt.AIFunction[]) {\n  return functions.reduce((map, func) => {\n    map.set(func.spec.name, func);\n    return map;\n  }, new Map<string, Prompt.AIFunction>());\n}\n"]}