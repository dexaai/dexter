{"version":3,"file":"ai-extract-function.js","sourceRoot":"","sources":["../../../src/prompt/functions/ai-extract-function.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,GAAG,EAAe,MAAM,aAAa,CAAC;AAC/C,OAAO,EAAE,gBAAgB,EAAE,MAAM,kBAAkB,CAAC;AACpD,OAAO,EAAE,cAAc,EAAE,MAAM,gBAAgB,CAAC;AAEhD;;GAEG;AACH,MAAM,UAAU,uBAAuB,CACrC,EACE,SAAS,EACT,IAAI,EACJ,WAAW,EACX,MAAM,EACN,UAAU,GAAG,CAAC,EACd,aAAa,EACb,uBAAuB,GAgBxB;AACD;;;;GAIG;AACH,2BAE+C;IAE/C,uDAAuD;IACvD,MAAM,eAAe,GAAG,gBAAgB,CACtC;QACE,IAAI;QACJ,WAAW;QACX,UAAU,EAAE,MAAM;KACnB,EACD,KAAK,EAAE,IAAI,EAA4B,EAAE;QACvC,IAAI,2BAA2B;YAAE,OAAO,2BAA2B,CAAC,IAAI,CAAC,CAAC;;YACrE,OAAO,IAAI,CAAC;IACnB,CAAC,CACF,CAAC;IAEF,2EAA2E;IAC3E,uCAAuC;IACvC,MAAM,MAAM,GAAG,cAAc,CAAC;QAC5B,SAAS,EAAE,SAAS,CAAC,KAAK,CAAC;YACzB,MAAM,EAAE;gBACN,gDAAgD;gBAChD,KAAK,EAAE,SAAS,CAAC,SAAS,EAAE,CAAC,KAAK;gBAClC,aAAa,EAAE,EAAE,IAAI,EAAE;aACxB;SACF,CAAC;QACF,aAAa;QACb,SAAS,EAAE,CAAC,eAAe,CAAC;QAC5B,IAAI,EAAE,WAAW;QACjB,aAAa,EAAE,UAAU,GAAG,CAAC;QAC7B,uBAAuB;QACvB,eAAe,EAAE,CAAC,OAAO,EAAE,EAAE,CAAC,GAAG,CAAC,YAAY,CAAC,OAAO,CAAC;QACvD,eAAe,EAAE,CAAC,OAAO,EAAE,EAAE;YAC3B,OAAO,eAAe,CAAC,SAAS,CAAC,OAAO,IAAI,EAAE,CAAC,CAAC;QAClD,CAAC;KACF,CAAC,CAAC;IAEH,oDAAoD;IACpD,OAAO,KAAK,UAAU,GAAG,CAAC,MAAM,EAAE,OAAO;QACvC,MAAM,QAAQ,GAAG,MAAM,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;QAC/C,IAAI,QAAQ,CAAC,MAAM,KAAK,OAAO;YAAE,MAAM,QAAQ,CAAC,KAAK,CAAC;QACtD,OAAO,QAAQ,CAAC,OAAO,CAAC;IAC1B,CAAC,CAAC;AACJ,CAAC","sourcesContent":["import type { z } from 'zod';\nimport type { Model } from '../../model/index.js';\nimport { Msg, type Prompt } from '../index.js';\nimport { createAIFunction } from './ai-function.js';\nimport { createAIRunner } from './ai-runner.js';\n\n/**\n * Use OpenAI function calling to extract data from a message.\n */\nexport function createAIExtractFunction<Schema extends z.ZodObject<any>>(\n  {\n    chatModel,\n    name,\n    description,\n    schema,\n    maxRetries = 0,\n    systemMessage,\n    functionCallConcurrency,\n  }: {\n    /** The ChatModel used to make API calls. */\n    chatModel: Model.Chat.Model;\n    /** The name of the extractor function. */\n    name: string;\n    /** The description of the extractor function. */\n    description?: string;\n    /** The Zod schema for the data to extract. */\n    schema: Schema;\n    /** The maximum number of times to retry the function call. */\n    maxRetries?: number;\n    /** Add a system message to the beginning of the messages array. */\n    systemMessage?: string;\n    /** The number of function calls to make concurrently. */\n    functionCallConcurrency?: number;\n  },\n  /**\n   * Optional custom extraction function to call with the parsed arguments.\n   *\n   * This is useful for adding custom validation to the extracted data.\n   */\n  customExtractImplementation?: (\n    params: z.infer<Schema>\n  ) => z.infer<Schema> | Promise<z.infer<Schema>>\n): Prompt.ExtractFunction<Schema> {\n  // The AIFunction that will be used to extract the data\n  const extractFunction = createAIFunction(\n    {\n      name,\n      description,\n      argsSchema: schema,\n    },\n    async (args): Promise<z.infer<Schema>> => {\n      if (customExtractImplementation) return customExtractImplementation(args);\n      else return args;\n    }\n  );\n\n  // Create a runner that will call the function, validate the args and retry\n  // if necessary, and return the result.\n  const runner = createAIRunner({\n    chatModel: chatModel.clone({\n      params: {\n        // @TODO: use deep partial on clone/extend input\n        model: chatModel.getParams().model,\n        function_call: { name },\n      },\n    }),\n    systemMessage,\n    functions: [extractFunction],\n    mode: 'functions',\n    maxIterations: maxRetries + 1,\n    functionCallConcurrency,\n    shouldBreakLoop: (message) => Msg.isFuncResult(message),\n    validateContent: (content) => {\n      return extractFunction.parseArgs(content || '');\n    },\n  });\n\n  // Execute the runner and return the extracted data.\n  return async function run(params, context) {\n    const response = await runner(params, context);\n    if (response.status === 'error') throw response.error;\n    return response.content;\n  };\n}\n"]}