import Anthropic from '@anthropic-ai/sdk';
import type { ChatMessage } from 'openai-fetch';

const getDefaultMaxTokens = (model: string) => {
  return 1000
}

export function createAnthropicClient(apiKey?: string) {
  return new AnthropicWrapper(apiKey);
}

function throwIfNull(msg: ChatMessage): string {
  if (msg.content === null) {
    throw new Error(`Content cannot be null for message: ${JSON.stringify(msg)}`);
  }
  return msg.content;
}

function anthropicMessageToChatMessages(msg: Anthropic.MessageParam): ChatMessage[] {
    if (typeof msg.content === 'string') {
      return [{
        role: msg.role,
        content: msg.content,
      }]
    }

    // Anthropic returns a list of blocks
    let acc: ChatMessage[] = []
    let blocks = msg.content
    while (blocks.length > 0) {
      const block = blocks.shift()
      if (block === undefined) {
        throw new Error('Block is undefined')
      }
      if (block.type === 'text') {
        acc.push({
          role: msg.role,
          content: block.text,
        })
      } else if (block.type === 'tool_use') {
        const parsedInput = JSON.parse(block.input as string)
        const functionName = parsedInput.name
        const functionArguments = parsedInput.arguments

        if (acc.length > 0 && acc[acc.length - 1].role === 'assistant' && acc[acc.length - 1].tool_calls === undefined) {
          acc.push({
            role: 'assistant',
            content: null,
            tool_calls: [{
              id: block.id,
              type: 'function',
              // anthropic input is unknown
              function: {
                name: functionName,
                arguments: functionArguments,
              }
            }],
          })
        } else {
          acc[acc.length - 1].tool_calls?.push({
            id: block.id,
            type: 'function',
            function: {
              name: functionName,
              arguments: functionArguments,
            }
          })
        }
      } else if (block.type === 'tool_result') {
        const content = block.content
        if (typeof content === 'string') {
          acc.push({
            role: 'assistant',
            content
          })
        } else if (content && content.length > 0) {
          while (content.length > 0) {
            const contentBlockParam = content.shift()
            if (contentBlockParam === undefined) {
              throw new Error('Content block parameter is undefined')
            }
            acc.push({
              role: 'assistant',
              // Don't support Anthropic.Messages.ImageBlockParam type yet
              content: contentBlockParam.type === 'text' ? contentBlockParam.text : null,
            })
          }
        } else {
          throw new Error('Invalid content type for tool_result, expected string or array of tool_result');
        }
      }
    }
  return acc
}

function chatMessagesToAnthropicMessages(messages: ChatMessage[]): Anthropic.MessageParam[] {
  let functionCallId = 0

  let prevMessageRole: string | undefined = undefined
  return messages.map(msg => {
    prevMessageRole = msg.role
    // role can be 'system' | 'user' | 'assistant' | 'function' | 'tool';
    switch (msg.role) {
      case 'system':
      case 'assistant':
        throwIfNull(msg)
        if (prevMessageRole === 'tool' || prevMessageRole === 'function') {
          if (!msg.tool_call_id) {
            functionCallId++
          }
          return {
            role: 'user',
            content: [{
              tool_use_id: msg.tool_call_id || functionCallId,
              type: 'tool_result',
              content: msg.content || '', // this could actually be a text or image block
              is_error: false, // not sure what to do here yet,
            } as Anthropic.Messages.ToolResultBlockParam]
          };
        }
        return {
          role: 'assistant',
          content: msg.content || '',
        };
      case 'user':
        throwIfNull(msg)
        return {
          role: 'user',
          content: msg.content || '',
        };
      case 'tool':
      case 'function':
          /** The tool calls generated by the model, such as function calls. */
          // tool_calls?: ToolCall[];
          /**
           * Tool call that this message is responding to.
           */
          // tool_call_id?: string;

            // id: string;

            // input: unknown;

            // name: string;

            // type: 'tool_use';

        const toolCalls = msg.tool_calls
        const toolCallId = msg.tool_call_id
        const functionCall = msg.function_call
        const toolCall = toolCalls?.find(call => call.id === toolCallId)

        return {
          role: 'assistant',
          content: [{
            type: 'tool_use',
            id: toolCallId,
            input: JSON.stringify(functionCall?.arguments || toolCall?.function.arguments),
            name: functionCall?.name || toolCall?.function.name,
          } as Anthropic.Messages.ToolUseBlockParam]
        };
      default:
        throw new Error(`Unknown role: ${msg.role}`);
    }
  });
}

class AnthropicWrapper {
  private client: Anthropic;

  constructor(apiKey?: string) {
    this.client = new Anthropic({
      apiKey: apiKey // defaults to process.env.ANTHROPIC_API_KEY,
    });
  }

  async createChatCompletion(params: {
    messages: ChatMessage[];
    model: string;
    max_tokens?: number;
    temperature?: number;
    [key: string]: any;
  }) {
    const { messages, model, max_tokens, temperature, ...rest } = params;

    const anthropicMessages = chatMessagesToAnthropicMessages(messages)

    const response = await this.client.messages.create({
      model,
      max_tokens: max_tokens || getDefaultMaxTokens(model),
      temperature: temperature,
      messages: anthropicMessages,
      stream: false,
      ...rest,
    });


    // todo: do something with the response

  }

  async streamChatCompletion(params: {
    messages: ChatMessage[];
    model: string;
    max_tokens?: number;
    temperature?: number;
    handleUpdate?: (message: string) => void;
    [key: string]: any;
  }) {
    const { messages, model, max_tokens, temperature, handleUpdate, ...rest } = params;

    const anthropicMessages = chatMessagesToAnthropicMessages(messages)

    const stream = await this.client.messages.stream({
      model,
      max_tokens: max_tokens || getDefaultMaxTokens(model),
      temperature: temperature,
      messages: anthropicMessages,
      ...rest,
    }).on('text', (text) => {
      if (handleUpdate) {
        handleUpdate(text);
      }
    });

    for await (const messageStreamEvent of stream) {
      console.log(messageStreamEvent.type);
    }

    // do something, and call anthropicMessagesToChatMessages
  }
}
